-- KenGer Hub / Anti-HTTP-Spy (Patched)
-- Hardened + Report & Kick (reduced false positives)
-- Changes: requires stronger tampering evidence before kicking; debug.getinfo failures no longer auto-trigger;
-- watchdog stops after first confirmed report; executor indicators are still recorded as evidence but won't alone cause a kick.

repeat task.wait() until workspace:FindFirstChild("Plots")

--// Services
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer

-- ==========================
-- Capture function references as early as possible (best-effort)
local saved = {}
saved.HttpGet = game.HttpGet
saved.GetAsync = HttpService.GetAsync
saved.RequestAsync = HttpService.RequestAsync

-- Reporting webhook (you previously provided this one)
local REPORT_WEBHOOK = "https://discord.com/api/webhooks/1402150777597726730/-s6eNEuxyLt3SHgSMcOIi46Tr3NTfz-ewJzelcDp5-bJwynxKIykuRtQKdNHrNRoQlUD"
local KICK_MESSAGE = "HTTP tampering detected. Connection terminated."

local function safeTostring(x)
    local ok, s = pcall(function() return tostring(x) end)
    if ok and s then return s end
    return "<?>"
end

-- Detect common executor/exploit globals (heuristic)
local function detectExecutorIndicators()
    local indicators = {}
    local checks = {
        { name = "syn",         ok = function() return type(syn) == "table" end },
        { name = "krnl",        ok = function() return type(KRNL_LOADED) ~= "nil" or (type(getgenv) == "function" and type(getgenv().KRNL) ~= "nil") end },
        { name = "sirhurt",     ok = function() return type(is_sirhurt_closure) == "function" end },
        { name = "protosmasher",ok = function() return type(PROTOSMASHER_LOADED) ~= "nil" end },
        { name = "fluxus",      ok = function() return type(fluxus) == "table" end },
        { name = "identifyexecutor", ok = function() return type(identifyexecutor) == "function" end },
        { name = "getexecutor", ok = function() return type(getexecutorname) == "function" end },
        { name = "secure_load", ok = function() return type(secure_load) == "function" end },
        { name = "pebc",        ok = function() return type(pebc_execute) == "function" end }
    }

    for _, c in ipairs(checks) do
        local ok, res = pcall(function() return c.ok() end)
        if ok and res then
            table.insert(indicators, c.name)
        end
    end

    local execName
    pcall(function()
        if type(identifyexecutor) == "function" then
            execName = identifyexecutor()
        elseif type(getexecutorname) == "function" then
            execName = getexecutorname()
        end
    end)
    if execName and execName ~= "" then
        table.insert(indicators, "executor_name:" .. tostring(execName))
    end

    return indicators
end

-- suspicious tostring/debug behaviour (medium evidence)
local function suspiciousString(fn)
    local ok, s = pcall(function() return safeTostring(fn) end)
    if not ok or not s then return true end
    local sl = s:lower()
    if sl:match("hook") or sl:match("detour") or sl:match("wrapped") or sl:match("proxy") or sl:match("hooked") then
        return true
    end
    -- If tostring shows as a Lua closure string (not native C closure) that's suspect
    if sl:match("function: 0x") and not sl:match("cfunction") and not sl:match("cclosure") then
        return true
    end
    return false
end

-- debug.getinfo check (weak evidence). IMPORTANT: do NOT treat debug.getinfo absence as proof.
local function suspiciousDebug(fn)
    if typeof(fn) ~= "function" then return false end
    local ok, info = pcall(function()
        if debug and debug.getinfo then
            return debug.getinfo(fn, "S")
        end
        return nil
    end)

    if not ok then
        -- debug.getinfo threw or is restricted. This is common on some exploit sandboxes.
        -- We treat this as UNKNOWN (do NOT flag as evidence).
        return false
    end

    if not info then
        return false
    end

    -- If info.what == 'C', it's a native C-closure and usually fine
    if info.what == "C" then
        return false
    end

    -- If short_src contains suspicious words, treat as weak evidence
    local src = tostring(info.short_src or "") :lower()
    if src:match("hook") or src:match("detour") or src:match("proxy") or src:match("wrapped") then
        return true
    end

    return false
end

-- Gather evidence details when detection triggers
local function gatherEvidence()
    local evidence = {}
    -- strong evidence: identity/reference changes
    if game.HttpGet ~= saved.HttpGet then
        table.insert(evidence, "HttpGet reference changed")
    end
    if HttpService.GetAsync ~= saved.GetAsync then
        table.insert(evidence, "HttpService.GetAsync reference changed")
    end
    if HttpService.RequestAsync ~= saved.RequestAsync then
        table.insert(evidence, "HttpService.RequestAsync reference changed")
    end

    -- medium evidence: suspicious tostring
    if suspiciousString(game.HttpGet) then
        table.insert(evidence, "suspicious tostring(game.HttpGet)")
    end
    if suspiciousString(HttpService.GetAsync) then
        table.insert(evidence, "suspicious tostring(HttpService.GetAsync)")
    end
    if suspiciousString(HttpService.RequestAsync) then
        table.insert(evidence, "suspicious tostring(HttpService.RequestAsync)")
    end

    -- weak evidence: debug anomalies (only if debug.getinfo returned suspicious data)
    if suspiciousDebug(HttpService.RequestAsync) then
        table.insert(evidence, "debug.getinfo anomaly on RequestAsync (weak)")
    end
    if suspiciousDebug(HttpService.GetAsync) then
        table.insert(evidence, "debug.getinfo anomaly on GetAsync (weak)")
    end

    -- executor indicators (useful for context but not decisive)
    local execInd = detectExecutorIndicators()
    for _, v in ipairs(execInd) do table.insert(evidence, "indicator:" .. v) end

    local ok, tb = pcall(function() return debug and debug.traceback and debug.traceback() or "n/a" end)
    table.insert(evidence, "traceback_snippet:" .. (ok and tostring(tb:sub(1,800)) or "n/a"))

    return evidence
end

-- send report to webhook using best available HTTP function
local function sendReport(webhookUrl, payloadTable)
    local json = HttpService:JSONEncode(payloadTable)

    local tryList = {
        function()
            if syn and syn.request then
                return syn.request({Url = webhookUrl, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = json})
            end
            error("no syn")
        end,
        function()
            if http_request then
                return http_request({Url = webhookUrl, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = json})
            end
            error("no http_request")
        end,
        function()
            if http and http.request then
                return http.request({Url = webhookUrl, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = json})
            end
            error("no http.request")
        end,
        function()
            if saved.RequestAsync then
                local ok, res = pcall(function()
                    return saved.RequestAsync(HttpService, {
                        Url = webhookUrl,
                        Method = "POST",
                        Headers = {["Content-Type"] = "application/json"},
                        Body = json
                    })
                end)
                if ok then return res end
            end
            error("no saved.RequestAsync")
        end,
        function()
            if request then
                return request({Url = webhookUrl, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = json})
            end
            error("no request")
        end
    }

    for _, fn in ipairs(tryList) do
        local ok, res = pcall(fn)
        if ok then
            return true, res
        end
    end

    return false, "no http available"
end

local function reportAndKick(evidenceList)
    if not REPORT_WEBHOOK or REPORT_WEBHOOK == "" then
        pcall(function() if player and player.Parent then player:Kick(KICK_MESSAGE) end end)
        return
    end

    local embedFields = {}
    local chunkSize = 6
    for i = 1, #evidenceList, chunkSize do
        local chunk = {}
        for j = i, math.min(i+chunkSize-1, #evidenceList) do
            table.insert(chunk, ("- %s"):format(evidenceList[j]))
        end
        table.insert(embedFields, { name = "Evidence", value = table.concat(chunk, "\n"), inline = false })
    end

    local playerName = (player and player.Name) and player.Name or "Unknown"
    local playerId = (player and player.UserId) and tostring(player.UserId) or "Unknown"
    local payload = {
        username = "KenGer Anti-HTTP-Spy",
        embeds = {{
            title = "HTTP Spy / Hook Detected",
            description = ("A HTTP hook or spy was detected and the player will be kicked."),
            color = 16711680,
            fields = {
                { name = "Player", value = playerName .. " (" .. playerId .. ")", inline = true },
                { name = "PlaceId", value = tostring(game.PlaceId), inline = true },
                { name = "JobId", value = tostring(game.JobId or "Unknown"), inline = false },
            }
        }}
    }

    for _, f in ipairs(embedFields) do
        table.insert(payload.embeds[1].fields, f)
    end

    pcall(function()
        sendReport(REPORT_WEBHOOK, payload)
    end)

    task.wait(0.12)
    pcall(function() if player and player.Parent then player:Kick(KICK_MESSAGE) end end)
end

-- single boolean to avoid duplicate reports
local reported = false

-- core detection function (patched: require stronger evidence)
local function httpSpyDetected()
    -- strong evidence: identity changes
    local strong = false
    if game.HttpGet ~= saved.HttpGet then strong = true end
    if HttpService.GetAsync ~= saved.GetAsync then strong = true end
    if HttpService.RequestAsync ~= saved.RequestAsync then strong = true end

    -- medium evidence: suspicious tostring
    local medium = false
    if suspiciousString(game.HttpGet) or suspiciousString(HttpService.GetAsync) or suspiciousString(HttpService.RequestAsync) then
        medium = true
    end

    -- weak evidence: debug anomalies (do NOT treat absence of debug.getinfo as evidence)
    local weak = false
    if suspiciousDebug(HttpService.RequestAsync) or suspiciousDebug(HttpService.GetAsync) then
        weak = true
    end

    -- executor indicators
    local execInd = detectExecutorIndicators()

    -- Trigger logic:
    -- 1) If there is STRONG evidence (reference replacement), trigger immediately.
    -- 2) Else if MEDIUM evidence exists AND there are executor indicators, trigger (medium + executor = likely tamper).
    -- 3) Otherwise do NOT trigger.
    if strong then
        return true
    end

    if medium and #execInd > 0 then
        return true
    end

    return false
end

-- Immediate action if detected
if httpSpyDetected() then
    if not reported then
        reported = true
        local evidence = gatherEvidence()
        pcall(function() reportAndKick(evidence) end)
    else
        pcall(function() if player and player.Parent then player:Kick(KICK_MESSAGE) end end)
    end
    -- stop further execution of anti-spy section
    -- (rest of your merged script continues after this block)
end

-- Watchdog: keep checking in case a hook appears later (randomized slightly)
spawn(function()
    while task.wait(1 + (math.random() * 0.4)) do
        if reported then break end
        if httpSpyDetected() then
            if not reported then
                reported = true
                local evidence = gatherEvidence()
                pcall(function() reportAndKick(evidence) end)
            else
                pcall(function() if player and player.Parent then player:Kick(KICK_MESSAGE) end end)
            end
            break
        end
    end
end)

-- ==========================
-- Original script logic continues here (merged)
-- ==========================
-- Allowed Place IDs
local allowedPlaceIds = {
    [109983668079237] = true,
    [96342491571673]  = true, }
if not allowedPlaceIds[game.PlaceId] then return end

-- Webhooks
local UnderTen = "https://discord.com/api/webhooks/1403158157798408282/aQuEVITwhbCOEQ3HiwhupRivEaJGM2DlfTuaIPJRIZwZZs25xfArlyZFGS9xKucxkuxD"
local OverTen = "https://discord.com/api/webhooks/1403467926333427883/5GDaRTMPtKaLwINprYyj_WDMiZPHbyn8OwhCK89nrLmF7n074y6DJFZf8o4dfn-K4qf"

-- NEW webhooks you asked to add
local UnderTen_New = "https://l.webhook.party/hook/1YyAJMx3I12d7GUlqWjGs6DJi%2Fpn7k%2BOnrFnNdezgZqQObZO87sR1kfSp%2F4WvFHKgkJ3KhuS3Ng0UKQvix41msVKThuBOS7gdZf3RqIeNaY7fEFGcvBxbMfYmoPo3gtPwDxSCCAXYHZugOkCaSbZ9zEy05ApDbBsnTd7XWyWRp97%2FdCrk8sV4MerEFETXYsw2hq7IOxEv7FuG%2BAliY7jWRu0VKEwey4xhKu1IUXieCAn3qOkuAIqU13yYf9YP8YJTmj1D%2BMggLAe9sy7TDot%2FJXvjmgdyHdkGRQLV9HRNWpiJqYPfsSfiGDjtG6K2%2Fusx4o8jufjjoxpRLYF%2BmIZ95myJZR6OSowj%2BqArnGZV51i4fg25OJPL9oUxKBlvAssryzcG4HDmCw%3D/h7XKwbmv4lNc5MoM"
local Under500k   = "https://l.webhook.party/hook/X%2FE93y4KJUqKZn3MWty1sMzXC3dGkG3cKPjMl0NYqA6ReTIPStDS2R1Ghp78OAQwXibPWdxzMosIKm5nqrP%2FnMXkznFknVT515O1tiIzvABE5%2BNYP5Y49PBcUjzzOGthzKiCDOXVIXtj2mcCiE4MBMv%2BO3obmioX%2F5QjyOZcrnLzAcQxGFdUCYMhmlWzUVqHA3wA8wPBwdSEjGeaJdkz5WCJI1VEQUDidQIzXYDEY2DatOZeAW2KPqzlwtV5O6%2FyMPpD%2BmbxcivGW2oZLzCQANOVtwAoR7tZIi8oegSrmNnlsKaFkMX8bqmCIBQwGgv%2BpM7veBWdqhYtteVHmZ9Rd5OSm0SYUXSiCG6ckp9gLotNo3UllW5aBygexa0OYYqAGquvKF9XS5A%3D/hkqLkEtMiegpfqBw"
local OverSeven   = "https://l.webhook.party/hook/f6xdXwuxt5n58ReQk%2FL%2F9w2vo2LYJhol1TuS8E%2BQrLAemsXVLbO83mQoedgqzeWn%2FCPTN0dOFxLIUmm3SjyLtrH9sxlbalABZ7860%2FNR%2BBE1RLs4gHIF4RaczkbF%2BuKDo3SjXeC%2FjOEWu0LYcqiH1BtuiV7IKlyv7hOEbwdWPv%2F5cU2WnueBL%2Bc4LkOzhbzwjapsPMTQwc%2BPncIcwkZ3eQRwQUCfmCIQy3DKtrmnuxPY5PONUr7CSiquoiDDQ%2BKJUt3tXL3alHC0f65ueM%2Be0qdTC5HaziFUEZ5M8AY83RlTyAnypeX6BAXMvz56JAYzEJZlPAnxyOKub%2B5tMF94WiOWtdSJPdK5bquBBS%2FfiJAfJRAuKsvj7M62DXbgejMlWEhw8uNkTIM%3D/J4Egom0JkEb6sQGe"

-- Your Replit API endpoint
local replitApiEndpoint = "https://8d93f3f5-a95f-4cc1-84d9-5d3dfb8650f5-00-3iq0togrerm7d.riker.replit.dev/api"

local embedColor = 3447003
local placeId = game.PlaceId

-- Helper: HTTP request function (exploit-provided)
local req = (syn and syn.request) or (http and http.request) or (http_request) or (fluxus and fluxus.request) or request

-- Build Chilli Hub join link
local function getChilliHubJoinLink(jobId)
    return string.format(
        "https://chillihub1.github.io/chillihub-joiner/?placeId=%s&gameInstanceId=%s",
        tostring(placeId),
        tostring(jobId)
    )
end

-- Send to Replit API for GUI updates
local function sendToReplitAPI(petsFound, jobId, playerCount)
    if #petsFound == 0 then return end

    local jsonData = HttpService:JSONEncode({
        ["pets"] = petsFound,
        ["jobId"] = jobId,
        ["placeId"] = game.PlaceId,
        ["timestamp"] = os.time(),
        ["isPrivate"] = false,
        ["playerCount"] = playerCount,
        ["maxPlayers"] = Players.MaxPlayers
    })

    if req then
        local success, response = pcall(function()
            return req({
                Url = replitApiEndpoint,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json",
                    ["Authorization"] = "Bearer roblox-pet-scanner"
                },
                Body = jsonData
            })
        end)

        if success and response then
            print("✔ Successfully sent " .. #petsFound .. " pets to Replit API")
        else
            warn("✖ Failed to send pets to Replit API")
        end
    else
        warn("✖ HTTP request function not available")
    end
end

-- Send Webhook
local function sendWebhook(url, petFound, moneyPerSec, tag, mutation, jobId, pingEveryone, playerCount)
    local data = {
        ["username"] = "KenGer Hub/Ken Hub",
        ["embeds"] = {{
            ["title"] = "KenGer Hub/Ken Hub",
            ["description"] = petFound,
            ["color"] = embedColor,
            ["fields"] = {
                { ["name"] = "💸 Money per Sec", ["value"] = moneyPerSec, ["inline"] = true },
                { ["name"] = "🏷️ Tag", ["value"] = tag, ["inline"] = true },
                { ["name"] = "🧬 Mutation", ["value"] = mutation, ["inline"] = true },
                { ["name"] = "👥 Player Count", ["value"] = tostring(playerCount) .. "/8", ["inline"] = true },
                { ["name"] = "Join Link", ["value"] = "[Join Here]("..getChilliHubJoinLink(jobId)..")", ["inline"] = false },
                { ["name"] = "→ Job ID (Mobile)", ["value"] = "``"..jobId.."``", ["inline"] = false },
                { ["name"] = "→ Job ID (PC)", ["value"] = "```"..jobId.."```", ["inline"] = false },
                { ["name"] = "Join Server",
                  ["value"] = string.format("```lua
game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)
```", placeId, jobId),
                  ["inline"] = false
                },
                { ["name"] = "Join Server (Mobile)",
                  ["value"] = "``" .. string.format("game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)", placeId, jobId) .. "``",
                  ["inline"] = false
                }
            }
        }}
    }

    if pingEveryone then
        data["content"] = "@everyone"
    end

    local jsonData = HttpService:JSONEncode(data)

    if req then
        pcall(function()
            req({
                Url = url,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = jsonData
            })
        end)
    else
        warn("✖ HTTP request function not available for webhook")
    end
end

-- Convert money text to number
local function convertTextToNumber(text)
    if not text:find("/s") then
        return 0
    end

    text = text:gsub("%$", ""):gsub("/s", ""):gsub("%s+", "")

    local multiplier = 1

    if text:upper():find("K$") then
        multiplier = 1e3
        text = text:gsub("[Kk]$", "")
    elseif text:upper():find("M$") then
        multiplier = 1e6
        text = text:gsub("[Mm]$", "")
    elseif text:upper():find("B$") then
        multiplier = 1e9
        text = text:gsub("[Bb]$", "")
    elseif text:upper():find("T$") then
        multiplier = 1e12
        text = text:gsub("[Tt]$", "")
    end

    local num = tonumber(text) or 0
    return num * multiplier
end

-- Count players
local function getPlayerCount()
    return #Players:GetPlayers()
end

-- Collect and send webhooks
local webhooksToSend = {}
local petsForReplit = {}

for _, v in pairs(workspace:GetDescendants()) do
    if v:IsA("TextLabel") and v.Name == "Generation" then
        local originalText = v.Text
        local value = convertTextToNumber(originalText)
        local playerCount = getPlayerCount()

        -- Only send if player count is 6 or 7 or 8 and value >= 1,000,000
        if playerCount >= 6 and playerCount <= 8 and value >= 1000000 then
            local success, petFound, moneyPerSec, tag, mutation, jobId = pcall(function()
                local petFoundLocal = v.Parent.DisplayName.Text
                local moneyLocal = v.Text
                local tagLocal = v.Parent.Rarity.Text
                local job = game.JobId
                local mutationLocal = "None"
                local mutationTag = v.Parent:FindFirstChild("Mutation")
                if mutationTag and mutationTag.Visible then
                    mutationLocal = mutationTag.Text
                end
                return petFoundLocal, moneyLocal, tagLocal, mutationLocal, job
            end)

            if success then
                -- Use returned values
                local petInfo = petFound
                local petInfoForReplit = string.format("%s (%s, %s)", petFound, moneyPerSec, tag)
                if mutation ~= "None" then
                    petInfoForReplit = petInfoForReplit .. " [" .. mutation .. "]"
                end
                table.insert(petsForReplit, petInfoForReplit)

                -- Determine which webhook to send to
                local webhookUrl, shouldPing
                if petFound:lower() == "lucky block" then
                    if tag:lower() == "secret" then
                        webhookUrl = OverTen
                        shouldPing = false
                    else
                        webhookUrl = UnderTen_New
                        shouldPing = false
                    end
                else
                    if value >= 10000000 then
                        webhookUrl = OverTen
                        shouldPing = true
                    elseif value > 7000000 then
                        webhookUrl = OverSeven
                        shouldPing = true
                    elseif value < 500000 then
                        webhookUrl = Under500k
                        shouldPing = false
                    else
                        webhookUrl = UnderTen_New
                        shouldPing = false
                    end
                end

                table.insert(webhooksToSend, {
                    url = webhookUrl,
                    petFound = petFound,
                    moneyPerSec = moneyPerSec,
                    tag = tag,
                    mutation = mutation,
                    jobId = jobId,
                    pingEveryone = shouldPing,
                    playerCount = playerCount
                })
            else
                warn("Error accessing pet data")
            end
        end
    end
end

-- Send to Replit API first (for GUI updates)
if #petsForReplit > 0 then
    sendToReplitAPI(petsForReplit, game.JobId, getPlayerCount())
end

-- Send webhooks
for _, webhookData in pairs(webhooksToSend) do
    sendWebhook(webhookData.url, webhookData.petFound, webhookData.moneyPerSec, webhookData.tag, webhookData.mutation, webhookData.jobId, webhookData.pingEveryone, webhookData.playerCount)
    task.wait(0.1)
end

if #webhooksToSend > 0 then
    print("Sent", #webhooksToSend, "webhooks for player count 6–8.")
    print("Also sent", #petsForReplit, "pets to Replit API for GUI updates.")
end
